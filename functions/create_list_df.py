{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "ab558843-2075-4cc7-87e7-09ee02bbb108",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import random \n",
    "import string\n",
    "from scipy.stats import truncnorm"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "id": "b8d03933-e780-48fb-a70b-592b8d027484",
   "metadata": {},
   "outputs": [],
   "source": [
    "#Funcion para calcular el numero de registros si random es False\n",
    "def get_random_rows(columns):\n",
    "    max_values = {} \n",
    "\n",
    "    for index, element in enumerate(columns):\n",
    "        element_type = element[\"type\"]\n",
    "        if element_type == \"numeric\":\n",
    "            max_values[index] = ((element[\"values\"][\"max\"]+1) - element[\"values\"][\"min\"])\n",
    "            \n",
    "        elif element_type == \"date\":\n",
    "            #calcular los dias de diferencia entre ambas fechas\n",
    "            number_days = (\n",
    "                pd.to_datetime(element[\"values\"][\"max\"]) - \n",
    "                pd.to_datetime(element[\"values\"][\"min\"])\n",
    "            ).days\n",
    "            max_values[index] = number_days + 1\n",
    "\n",
    "        elif element_type == \"category\":\n",
    "            max_values[index] = len(element[\"values\"])\n",
    "\n",
    "        elif element_type == \"unique\":\n",
    "            max_values[index] = 1\n",
    "    \n",
    "    max_key = max(max_values, key=max_values.get)\n",
    "    return { \n",
    "        \"column\" : max_key,\n",
    "        \"value\": max_values[max_key] }\n",
    "\n",
    "#Funcion para crear una lista de valores unicos\n",
    "def get_random_unique(n):\n",
    "    list_id = set()\n",
    "\n",
    "    while len(list_id) < n:\n",
    "        characters = string.ascii_letters + string.digits\n",
    "        id = ''.join(random.choices(characters, k = 16))\n",
    "        list_id.add(id)  \n",
    "    return list(list_id)\n",
    "\n",
    "#Funcion para crear categorias aleatorias\n",
    "def get_random_categories( items , n  ):\n",
    "    return random.choices(items, k=n)\n",
    "\n",
    "def get_random_numbers( min , max, n ):\n",
    "    values = []\n",
    "    for i in range(n):\n",
    "        values.append(random.randint(min, max))\n",
    "    return values\n",
    "\n",
    "def get_random_dates( min , max , n ):\n",
    "    items = pd.date_range( start = min , end = max , freq = 'D' )\n",
    "    return get_random_categories( items , n )\n",
    "\n",
    "def generate_truncated_normal_data(mean, std, min, max, n):\n",
    "    # Calcular los parámetros de la distribución normal truncada\n",
    "    a, b = (min - mean) / std, (max - mean) / std\n",
    "    data = truncnorm(a, b, loc=mean, scale=std).rvs(n)\n",
    "    return list(map(int, data))\n",
    "\n",
    "#Funcion para calcular la columna con mas valores en random = false\n",
    "def get_list_random_false(column):\n",
    "    data = []\n",
    "\n",
    "    if(column[\"type\"] == \"category\"):\n",
    "        data = column[\"values\"]\n",
    "    elif(column[\"type\"] == \"date\"):\n",
    "        items = pd.date_range( start = column[\"values\"][\"min\"] , end = column[\"values\"][\"max\"] , freq = 'D' )\n",
    "        data = list(items)\n",
    "    elif(column[\"type\"] == \"numeric\"):\n",
    "        data = list(range(column[\"values\"][\"min\"], column[\"values\"][\"max\"] +1 ) )\n",
    "    else:\n",
    "        raise Error_dataframe(\"La columna {} es de tipo de dato no válido\".format(column[\"name\"]))\n",
    "    return data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 43,
   "id": "e9fedfb6-4914-4c14-bc90-bb21b83f8bbf",
   "metadata": {},
   "outputs": [],
   "source": [
    "#Funcion para crear un dataFrame SIN FOREIGN\n",
    "def get_columns(columns, number_row, dependent_column = None):\n",
    "    data = {}\n",
    "\n",
    "    types = [ \"category\" , \"unique\" , \"date\", \"foreign\", \"numeric\"]\n",
    "    for index, element in enumerate(columns):\n",
    "        element_type = element[\"type\"]\n",
    "        if element_type in types:\n",
    "            if element_type == \"category\":\n",
    "                values = get_random_categories( element[\"values\"] , number_row  )\n",
    "\n",
    "            elif element_type == \"unique\":\n",
    "                values = get_random_unique(number_row)\n",
    "\n",
    "            elif element_type == \"date\":\n",
    "                values = get_random_dates( \n",
    "                    element[\"values\"][\"min\"], element[\"values\"][\"max\"]\n",
    "                    , number_row)\n",
    "\n",
    "            #aqui va el foreign\n",
    "            elif element_type == \"foreign\":\n",
    "                for j in dependent_column:\n",
    "                    if(element[\"values\"] == j[\"name_df\"]):\n",
    "                        values = get_random_categories( j[\"data\"] , number_row  )\n",
    "            \n",
    "            elif element_type == \"numeric\":\n",
    "                if \"std\" in element[\"values\"]:\n",
    "                    values = generate_truncated_normal_data(\n",
    "                        element[\"values\"][\"mean\"], element[\"values\"][\"std\"]\n",
    "                        , element[\"values\"][\"min\"], element[\"values\"][\"max\"]\n",
    "                        , number_row)\n",
    "                else:\n",
    "                    values = get_random_numbers( \n",
    "                        element[\"values\"][\"min\"], element[\"values\"][\"max\"]\n",
    "                        , number_row)\n",
    "        \n",
    "            data[element[\"name\"]] = values\n",
    "            \n",
    "    return pd.DataFrame( data )\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 58,
   "id": "5eaa1acb-aa69-44ce-9d8e-403a2041ecf4",
   "metadata": {},
   "outputs": [],
   "source": [
    "def create_dataframe(setting, dependent_column = None):\n",
    "    try:\n",
    "        if \"random\" not in setting:\n",
    "            raise ErrorDataFrame(\"El atributo 'random' es obligatorio\")\n",
    "        \n",
    "        if setting[\"random\"]:\n",
    "            if \"random_rows\" not in setting:\n",
    "                raise ErrorDataFrame(\"El atributo 'random_rows' es obligatorio\")\n",
    "            \n",
    "            if not isinstance(setting[\"random_rows\"], (int, float)):\n",
    "                raise ErrorDataFrame(\"El valor de 'random_rows' debe ser numérico\")\n",
    "                \n",
    "            n = int(setting[\"random_rows\"])\n",
    "\n",
    "            data = get_columns(setting[\"columns\"], n, dependent_column)\n",
    "            data.name = setting[\"ds\"]\n",
    "        \n",
    "        else:\n",
    "            copy_columns = setting[\"columns\"].copy()\n",
    "            max_rows = get_random_rows(setting[\"columns\"])\n",
    "            del copy_columns[max_rows[\"column\"]]\n",
    "            \n",
    "            data = get_columns(copy_columns, max_rows[\"value\"], dependent_column)\n",
    "            new_data = get_list_random_false(setting[\"columns\"][max_rows[\"column\"]])\n",
    "            name_column = setting[\"columns\"][max_rows[\"column\"]][\"name\"]\n",
    "            \n",
    "            data.insert(max_rows[\"column\"], name_column, new_data)\n",
    "            data.name = setting[\"ds\"]\n",
    "\n",
    "        return data\n",
    "    \n",
    "    except Exception as e:\n",
    "        print(f\"Error en la creación del DataFrame: {e}\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "2d4ff452-81a2-4361-b45f-50eb4a6c7614",
   "metadata": {},
   "outputs": [],
   "source": [
    "def search_foreign(dictionaries): \n",
    "    relations = {}\n",
    "    for dictionary in dictionaries:\n",
    "        for column in dictionary['columns']:\n",
    "            if column['type'] == 'foreign':\n",
    "                foreign_ds, foreign_col = column['values'].split('.')\n",
    "                found_dataset = False\n",
    "                found_foreign = False\n",
    "                for dic in dictionaries:\n",
    "                    if dic['ds'] == foreign_ds:\n",
    "                        found_dataset = True\n",
    "                        for col in dic['columns']:\n",
    "                            if col['name'] == foreign_col:\n",
    "                                relations[foreign_ds+\".\"+foreign_col] = dictionary['ds']\n",
    "                                found_foreign = True\n",
    "                                break\n",
    "                        if found_foreign:\n",
    "                            break\n",
    "                if not found_dataset:\n",
    "                    raise Error_dataframe(\n",
    "                        \"No se encontró el dataset {}. Verifique que el dataset exista.\".format(foreign_ds)\n",
    "                    )\n",
    "                if not found_foreign:\n",
    "                    raise Error_dataframe(\n",
    "                        \"No se encontró la columna {} en el dataset {}. \"\n",
    "                        \"Las posibles columnas son: {}\".format(\n",
    "                            foreign_col, foreign_ds, \n",
    "                            [col['name'] for col in dic['columns']]\n",
    "                        )\n",
    "                    )\n",
    "    return relations"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "66177f6f-4a5f-4777-879b-c84220d7977c",
   "metadata": {},
   "outputs": [],
   "source": [
    "class Error_dataframe(Exception):\n",
    "    def __init__(self, message):\n",
    "        super().__init__(message)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 67,
   "id": "56d59a7c-273d-47c0-bf2b-484e9bc6f388",
   "metadata": {},
   "outputs": [],
   "source": [
    "def build_dataframes(conf_list):\n",
    "    dataframe_list = []\n",
    "    try:\n",
    "        relations = search_foreign(conf_list)\n",
    "        \n",
    "        for element in conf_list:\n",
    "            dependent = False\n",
    "            for key in relations:\n",
    "                if element[\"ds\"] == relations[key]:\n",
    "                    dependent = True\n",
    "                    break\n",
    "                                \n",
    "            if not dependent:\n",
    "                new = create_dataframe(element)\n",
    "                dataframe_list.append(new)           \n",
    "                    \n",
    "        for element in conf_list:\n",
    "            if element[\"ds\"] in relations.values():\n",
    "                dependency = []\n",
    "                dependency_keys = [k for k, v in relations.items() if v == element[\"ds\"]]\n",
    "                \n",
    "                for k in dependency_keys:\n",
    "                    df, column = k.split(\".\")\n",
    "                    for index, item in enumerate(dataframe_list):\n",
    "                        if item.name == df:\n",
    "                            dependency.append(\n",
    "                                {\n",
    "                                    \"name_df\": k,\n",
    "                                    \"data\": list(dataframe_list[index][column])\n",
    "                                }\n",
    "                            )\n",
    "                \n",
    "                new = create_dataframe(element, dependency)\n",
    "                dataframe_list.append(new)                      \n",
    "                                   \n",
    "        return dataframe_list\n",
    "    except Exception as e:\n",
    "        print(f\"Error en la build_dataframes: {e}\")    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 68,
   "id": "5b23077d-6e35-417c-8762-ea3daec31c0b",
   "metadata": {},
   "outputs": [],
   "source": [
    "conf_list = [d2,d4,d1, d3, d5]\n",
    "dataframe_list = build_dataframes(conf_list)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "29879d74-1173-4451-9055-90e30b1e5884",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
